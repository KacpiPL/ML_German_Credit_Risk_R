---
title: "ML - German_Credit_Risk"
author: "Bryzik Michał, Gruca Kacper"
date: "2024-01-09"
output: 
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, include=FALSE}
options(width = 60)
local({
  hook_output <- knitr::knit_hooks$get('output')
  knitr::knit_hooks$set(output = function(x, options) {
    if (!is.null(options$max.height)) options$attr.output <- c(
      options$attr.output,
      sprintf('style="max-height: %s;"', options$max.height)
    )
    hook_output(x, options)
  })
})
```

## Introduction

Classification problem

The main goal of this paper is to apply ML methods, especially Decision Trees to the classify clients.


```{r, message=FALSE}
library(tidyverse)
library(DT)
library(dplyr)
library(fastDummies)
library(caret)
library(ggplot2)
library(plotfunctions)
```

## Data cleaning

Read csv
```{r}
df <- read.csv("data/input/c2.csv")
```

Below we can observe raw dataframe and its format of the columns:

```{r, echo=FALSE}
datatable(df, options = list(
  searching = FALSE,
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),
  scrollX = TRUE
), width = "100%")  # Adjust the width as needed
```

```{r, max.height='150px'}
str(df)
```

### Delete quotations

As we can observe all chr columns have additiona quotes '', let's delete them.

```{r}
df <- df %>%
  mutate_if(is.character, function(x) gsub("'", "", x))
```

### Missing values

Dataframe does not have any missing values, as we can see below

```{r}
## Getting the number of missing values in each column
num_missing <-  colSums(is.na(df))

# Excluding columns that contains 0 missing values
num_missing <-  num_missing[num_missing > 0]
num_missing

```

### Handle Categorical variables

Select all columns with chr data type - we treat them as categorical

```{r}
chr_columns <- names(df[, sapply(df, is.character)])
chr_columns
```

Create df with categorical variables, print unique values of each column.

```{r}
# Function to print unique values for each column in dataframe
print_unique_values <- function(df){
  
  df_unique <- lapply(df, unique)
  # Print unique values for each column
  for (col_name in names(df_unique)) {
    cat(col_name, ": ", paste(df_unique[[col_name]], collapse = ", "), "\n")
  }
}

```

```{r}
df_categorical <- df[chr_columns]

print_unique_values(df_categorical)
       
```

#### Personal status column

Let's focus on the column "personal_status", here we have 2 information, sex and marital status

We should separate them into 2 columns:

* sex (0 - female, 1 - male)
* marital_status:
  + single
  + div/dep/mar
  + mar/wid
  + div/sep

Check the size of each group:

```{r}
personal_status_counts <- table(df$personal_status)

print(personal_status_counts)
```

Create 2 new columns:

```{r}
# Extracting sex information
df <- df %>%
  mutate(sex = ifelse(grepl("female", personal_status), 0, 1))

# Extracting the rest of the information
df <- df %>%
  mutate(marital_status = sub("^[^ ]+ ", "", sub(" $", "", personal_status)))

# Drop the original "personal_status" column
df <- df %>%
  select(-personal_status)
```

```{r}
sex_counts <- table(df$sex)
marital_status_counts <- table(df$marital_status)

print(sex_counts)
print(marital_status_counts)
```

Create a list of reamining chr columns which needs to be handled yet

```{r}
# Copy chr columns and remove personal_status - now we have list with remaining chr columns
chr_columns_help <- chr_columns

# Remove "personal_status" from list
chr_columns_help <- setdiff(chr_columns_help, "personal_status")

# Adding marital_status to object_columns_help
chr_columns_help <- union(chr_columns_help, "marital_status")

print(chr_columns_help)
```

#### Ordered categorical variables

In the dataset we can observe a few ordered categorical variables. Let's define and transform them.

```{r}
# Refresh the df_categorical and show unique values - columns to be handled yet

df_categorical <- df[, chr_columns_help]
print_unique_values(df_categorical)
       
```

Let's define ordered categorical variables:

```{r}
ordered_categorical = c("checking_status", "employment", "job", "savings_status")
head(df[, ordered_categorical])
```

Define values for each category

```{r}
checking_status_mapping <- c(
  "<0" = 1, 
  "0<=X<200" = 2, 
  ">=200" = 3, 
  "no checking" = 4)

employment_mapping <- c(
  "unemployed" = 1, 
  "<1" = 2, 
  "1<=X<4" = 3, 
  "4<=X<7"= 4, 
  ">=7" = 5)

job_mapping <- c(
    "unemp/unskilled non res" = 1,
    "unskilled resident" = 2,
    "skilled" = 3,
    "high qualif/self emp/mgmt" = 4
)

savings_status_mapping <- c(
    "no known savings" = 1,
    "<100" = 2,
    "100<=X<500" = 3,
    "500<=X<1000" = 4,
    ">=1000" = 5
)

# Define the mapping function
recode_variable <- function(variable, mapping) {
  variable <- factor(variable, levels = names(mapping))
  return(as.numeric(variable))
}

df$checking_status <- recode_variable(df$checking_status, checking_status_mapping)
df$employment <- recode_variable(df$employment, employment_mapping)
df$job <- recode_variable(df$job, job_mapping)
df$savings_status <- recode_variable(df$savings_status, savings_status_mapping)
```

Update the chr_columns_help - delete ordered categorical columns and print

```{r}
# Remove ordered_categorical variables names from list
chr_columns_help <- setdiff(chr_columns_help, ordered_categorical)
```

#### Boolean variables

Let’s define boolean variables:

```{r}
boolean_variables = c("class", "foreign_worker", "own_telephone")
head(df[, boolean_variables])
```

```{r}
df$class <- ifelse(grepl("good", df$class), 1, 0)
df$foreign_worker <- ifelse(grepl("yes", df$foreign_worker), 1, 0)
df$own_telephone <- ifelse(grepl("yes", df$own_telephone), 1, 0)
```

```{r}
# Remove boolean_variables variables names from list
chr_columns_help <- setdiff(chr_columns_help, boolean_variables)
```

#### One-hot encoding

For the remaining columns we apply one-hot encodig

```{r}
# Print remaining categorical variables and its unique values
df_categorical <- df[, chr_columns_help]
print_unique_values(df_categorical)
```

```{r}
df <- dummy_cols(
  df, 
  select_columns = chr_columns_help, 
  remove_first_dummy = TRUE, 
  remove_selected_columns = TRUE)
```

### Summary of data cleaning

We performed data cleaning in a few steps:

* Delete quotations (clean chr variables)
* Handle categorical variables divided into:
  + Personal status column - divde column into 2 columns
  + Ordered categorical variables
  + Boolean variables
  + Categorical variable (one-hot encoding)
  
After this transformations we obtained dataframe with 51 variables.

As we can see below, after the data transformation there are no missing values, so the data transformation process was successful.

```{r}
## Getting the number of missing values in each column
num_missing <-  colSums(is.na(df))

# Excluding columns that contains 0 missing values
num_missing <-  num_missing[num_missing > 0]
num_missing
```

Below we can see the new dataframe and its columns along with their value types

```{r, echo=FALSE}
datatable(df, options = list(
  searching = FALSE,
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),
  scrollX = TRUE
), width = "100%")  # Adjust the width as needed
```


```{r, max.height='150px'}
str(df)
```

### Splitting the dataset

Before performing Exploratory Data Analysis we should divide our dataset into train and test, we do it as below:

```{r}
set.seed(123456789)
training_obs <- createDataPartition(df$id, 
                                    p = 0.7, 
                                    list = FALSE) 
df.train <- df[training_obs,]
df.test  <- df[-training_obs,]
```

```{r, echo=FALSE}
# remove unecessary variables
rm(list = setdiff(ls(), c("df", "df.test", "df.train", "print_unique_values")))

# write df.train and df.test
write.csv(df.test, "./data/output/df.test.csv", row.names = FALSE)
write.csv(df.train, "./data/output/df.train.csv", row.names = FALSE)
```

## Exploratory Data Analysis

Divide variables

```{r, max.height='150px'}
# define numeric variables
numeric_variables <- c("age",
                       "checking_status",
                       "credit_amount",
                       "duration",
                       "employment",
                       "existing_credits",
                       "installment_commitment",
                       "num_dependents",
                       "residence_since")

# define feat variables
feat_variables <- c()
for (i in 1:10){
  if (i < 10){
    var <- paste("feat0", i, sep="")
  } else {
    var <- paste("feat", i, sep="")
  }
  feat_variables <- append(feat_variables, var)
}

# define ordered_categorical
ordered_categorical = c("checking_status", "employment", "job", "savings_status")

# define boolean variables
boolean_variables <- setdiff(colnames(df.train), c("id", numeric_variables, feat_variables, ordered_categorical))

# check if the division was made properly
print_unique_values(df[,boolean_variables])
```

Make histograms of numeric variables

```{r}
par(mfrow=c(3, 4))

for (var in numeric_variables) {
    hist(df[[var]], main=paste("Histogram of", var), xlab=var)
}
```

```{r}

```



