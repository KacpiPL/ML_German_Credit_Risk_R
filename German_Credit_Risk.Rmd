---
title: "ML - German_Credit_Risk"
author: "Bryzik Michał, Gruca Kacper"
date: "2024-01-09"
output: 
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

The main goal of this paper is to apply ML methods, especially Decision Trees to the classify clients.

Dopisać cos

```{r, message=FALSE}
library(tidyverse)
library(DT)
library(dplyr)
```

## Data_preparation

Read csv
```{r}
df <- read.csv("data/input/c2.csv")
```

Below we can observe raw dataframe and its format of the columns:

```{r, echo=FALSE}
datatable(df, options = list(
  searching = FALSE,
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),
  scrollX = TRUE
), width = "100%")  # Adjust the width as needed
```

```{r}
str(df)
```

### Delete quotations

As we can observe all chr columns have additiona quotes '', let's delete them.

```{r}
df <- df %>%
  mutate_if(is.character, function(x) gsub("'", "", x))
```

### Missing values

Dataframe does not have any missing values, as we can see below

```{r}
## Getting the number of missing values in each column
num_missing <-  colSums(is.na(df))

# Excluding columns that contains 0 missing values
num_missing <-  num_missing[num_missing > 0]
num_missing

```

### Handle Categorical variables

Select all columns with chr data type - we treat them as categorical

```{r}
chr_columns <- names(df[, sapply(df, is.character)])
chr_columns
```

Create df with categorical variables, print unique values of each column.

```{r}
# Function to print unique values for each column in dataframe
print_unique_values <- function(df){
  
  df_unique <- lapply(df, unique)
  # Print unique values for each column
  for (col_name in names(df_unique)) {
    cat(col_name, ": ", paste(df_unique[[col_name]], collapse = ", "), "\n")
  }
}

```

```{r}
df_categorical <- df[chr_columns]

print_unique_values(df_categorical)
       
```

#### Personal status column

Let's focus on the column "personal_status", here we have 2 information, sex and marital status

We should separate them into 2 columns:

* sex (0 - female, 1 - male)
* marital_status:
  + single
  + div/dep/mar
  + mar/wid
  + div/sep

Check the size of each group:

```{r}
personal_status_counts <- table(df$personal_status)

print(personal_status_counts)
```

Create 2 new columns:

```{r}
# Extracting sex information
df <- df %>%
  mutate(sex = ifelse(grepl("female", personal_status), 0, 1))

# Extracting the rest of the information
df <- df %>%
  mutate(marital_status = sub("^[^ ]+ ", "", sub(" $", "", personal_status)))

# Drop the original "personal_status" column
df <- df %>%
  select(-personal_status)
```

```{r}
sex_counts <- table(df$sex)
marital_status_counts <- table(df$marital_status)

print(sex_counts)
print(marital_status_counts)
```

Create a list of reamining chr columns which needs to be handled yet

```{r}
# Copy chr columns and remove personal_status - now we have list with remaining chr columns
chr_columns_help <- chr_columns

# Remove "personal_status" from list
chr_columns_help <- setdiff(chr_columns_help, "personal_status")

# Adding marital_status to object_columns_help
chr_columns_help <- union(chr_columns_help, "marital_status")

print(chr_columns_help)
```

#### Ordered categorical variables

In the dataset we can observe a few ordered categorical variables. Let's define and transform them.

```{r}
# Refresh the df_categorical and show unique values - columns to be handled yet

df_categorical <- df[, chr_columns_help]
print_unique_values(df_categorical)
       
```

Let's define ordered categorical variables:

```{r}
ordered_categorical = c("checking_status", "employment", "job", "savings_status")
head(df[, ordered_categorical])
```

Define values for each category

```{r}
checking_status_mapping <- c(
  "<0" = 1, 
  "0<=X<200" = 2, 
  ">=200" = 3, 
  "no checking" = 4)

employment_mapping <- c(
  "unemployed" = 1, 
  "<1" = 2, 
  "1<=X<4" = 3, 
  "4<=X<7"= 4, 
  ">=7" = 5)

job_mapping <- c(
    "unemp/unskilled non res" = 1,
    "unskilled resident" = 2,
    "skilled" = 3,
    "high qualif/self emp/mgmt" = 4
)

savings_status_mapping <- c(
    "no known savings" = 1,
    "<100" = 2,
    "100<=X<500" = 3,
    "500<=X<1000" = 4,
    ">=1000" = 5
)

# Define the mapping function
recode_variable <- function(variable, mapping) {
  variable <- factor(variable, levels = names(mapping))
  return(as.numeric(variable))
}

df$checking_status <- recode_variable(df$checking_status, checking_status_mapping)
df$employment <- recode_variable(df$employment, employment_mapping)
df$job_mapping <- recode_variable(df$job, job_mapping)
df$savings_status <- recode_variable(df$savings_status, savings_status_mapping)
```

Update the chr_columns_help - delete ordered categorical columns and print

```{r}
# Remove ordered_categorical variables names from list
chr_columns_help <- setdiff(chr_columns_help, ordered_categorical)
```

#### Other categorical variables

```{r}
# Print remaining categorical variables and its unique values
df_categorical <- df[, chr_columns_help]
print_unique_values(df_categorical)
```

#### Boolean variables

Let’s define boolean variables:

```{r}
boolean_variables = c("class", "foreign_worker", "own_telephone")
head(df[, boolean_variables])
```

```{r}
df$class <- ifelse(grepl("good", df$class), 1, 0)
df$foreign_worker <- ifelse(grepl("yes", df$foreign_worker), 1, 0)
df$own_telephone <- ifelse(grepl("yes", df$own_telephone), 1, 0)
```

```{r}
# Remove boolean_variables variables names from list
chr_columns_help <- setdiff(chr_columns_help, boolean_variables)
```

```{r}
# Print remaining categorical variables and its unique values
df_categorical <- df[, chr_columns_help]
print_unique_values(df_categorical)
```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```



